# 哈希表

# 哈希表
> 通过散列函数  算出  数据存储的位置 使之达到 O(1) 级的访问效率


	|  姓名| 班级 |  成绩
	
	|  张三| 1|  70
	
	|  李四| 2|  86
	
	哈希表：

	|a   |b   |c   |d   |e   |f   |g   |h   |i   |j   |k 


	|0   |1   |2   |3   |4   |5   |6   |7   |8   |9   |10

	-------------------------------------------------------
	|l   |m   |n   |o   |p   |q   |r  |s   |t   |u   |v     
	
	|11  |12  |13  |14  |15  |16  |17 |18  |19  |20  |21

	-------------------------------------------------------
	|w   |x   |y   |z
	
	|22  |23  |24  |25

	
	//张三  姓名首字母为 z 和 s  对比哈希表得出 25 + 18 = 43； 算出这一条数据的存储位置
	//那么  arr[43]  =  70/*张三成绩*/

	//李四  姓名首字母为 l 和 s  对比哈希表得出 11 + 18 = 29；算出这一条数据的存储位置
	//那么  arr[29]  =  86/*李四成绩*/

# 哈希冲突

> 两个以上的键值映射到同一个索引
> 
> 通过散列函数 算出数据存储位置  得到高效率的访问效率，但不可避免的产生了哈希冲突 
> 
> 哈希冲突指两个独立的个体（数据） 通过 散列函数 得到相同的结果（存储位置），比如 下面的例子

	
	|  姓名 |  班级   |  成绩
		
	|  李斯 |  3     |  75

	//李斯  姓名首字母为 l 和 s  对比哈希表得出 11 + 18 = 29；算出这一条数据的存储位置
	//那么  arr[29]  =  75/*李斯成绩*/

> 这个例子得到的结果和上面李四的结果是一致的  李斯和李四的存储位置都是29  。 但一个位置不会存两份数据  。 这就是哈希冲突

> 
> 哈希冲突是不可避免的 需要解决

# 解决哈希冲突的方式

> 1.开放定址法：产生冲突时，先从该位置后面找，找到空位，再填入数据 并记录这个位置
> 
> 需要大于数据量的空间
> 
> 2.再哈希法：发生冲突时 使用第二个、第三个散列函数 、第四个散列函数 算位置 直到没有冲突
> 
> 3.链地址法（常用）：相同位置冲突的形成一个链表  一个冲突指向下一个冲突
> 
> 4.选取恰当的散列函数 减少哈希冲突  

# 散列函数
>选取：
>
> 1.尽可能平均分布在散列表
> 
> 2.关键字极小的变化引起哈希值极大的变化




> 方法：

> 1.除法散列法  ：
> 
> f (key) = value%p;
> 
> p 为 0-value的最大质数

> 
> 2.平方散列法  ：
> 
> f (key) = value*value >> d ;
> 
> d 为一整数 保证数字不溢出
> 
> 2.斐波那契散列法  ：
> 

> 
> 16       Fibonacci = 40503
> 
> 32       Fibonacci = 2654435769
> 
> 64       Fibonacci = 11400714819323198485

> f (key) = value*Fibonacci >> 28 ;

